# lab 4 report

## Task 1 
In this task, we generated 100,000 passwords according to the specified characteristics. A set of 100,000 passwords consists of 70 percent of the "top 100,000 passwords" list, 10 percent of the "top 100 popular passwords" list, as well as 10 percent of completely random passwords, and the rest are plausible human passwords.

The next step was to choose two hashing schemes proposed in the task. The first is MD5 and the second is sha-1 + salt.

sha1 + salt hash
<img src="lab4/img/img1.png" alt="drawing" width="300"/>


md5 hash
<img src="lab4/img/img2.png" alt="drawing" width="300"/>




## Task 2

For the second task, we first installed hashcat and got acquainted with its functionality. 
Hashcat is the world's fastest password cracker. However, this is not the easiest program to use - you need to spend time learning it. A feature of hashcat is a very high speed of brute-force password search, which is achieved due to the simultaneous use of all video cards, as well as processors in the system.
We can use **hashcat -b** command to do a benchmark

![alt text](lab4/img/img3.png "Title")

There are different ways to extract passwords from hashes.
- Brute force
- Patterns
- Rainbow tables
- Dictionary

We'll try to use our "Top passwords" text file as a dictionary argument for our hashcat crack. 
The file initially contained a large number of passwords, which forms the base of our hashes, therefore, such a hack will be very fast and efficient.

Only our processor was used in this crack. 
Some optimizers was applied by Hashcat:
* Zero-Byte
* Early-Skip
* Not-Salted
* Not-Iterated
* Single-Salt
* Raw-Hash

Result: 

![alt text](lab4/img/img4.png "Title")

Decrypted passwords:
<img src="lab4/img/img5.png" alt="drawing" width="600"/>

## Recomendations and summary:

As we know, there are a huge number of popular passwords, and, accordingly, their hashes are already familiar to cybercriminals. (About 5 billion) If we check our hashes using online decryption services, we will see that the program is not familiar with hashes obtained from human-like passwords(generated by my program), but is very familiar with passwords that are included in the Top lists.

Top 100 000 passwords hashes:
<img src="lab4/img/img6.png" alt="drawing" width="500"/>

Human-like passwords hashes:
<img src="lab4/img/img7.png" alt="drawing" width="500"/>

> CrackStation uses massive pre-computed lookup tables to crack password hashes. These tables store a mapping between the hash of a password, and the correct password for that hash. The hash values are indexed so that it is possible to quickly search the database for a given hash. If the hash is present in the database, the password can be recovered in a fraction of a second. This only works for "unsalted" hashes.

My recommendations:
- Use more secure and modern hash functions (SHA - 2 set)
- Use time delay functions for hashing passwords and sensitive information (argon 2)
- To store the user's password in an even more secure form, you need to use SHA-2 and Aragon2 after that.
- Do not use hash functions with a high probability of collisions, for example, md-5, because it can be used by the hacker for forging e-documents and other fraudulent manipulations
- A hash function should always work in one direction only.
- Hash functions and data protection algorithms must be so complex that the cost of breaking them for attackers is higher than the value of the information that is encrypted
- There are such ways to crack the hash database: brute force, rainbow tables, dictionaries, patterns. The large length of the encrypted text increases the time that needs to be spent on cracking a lot. Accordingly, the secure password must be more than 8 characters in length.
- Salt is used to ensure that two users with the same passwords do not have the same hash

Hack result for a random student dataset of hashes cracked with my Hashcat provided: 
**lab4/Data Sets/cracked.txt**