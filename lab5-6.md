# lab 6 report

## Auth and pasword storage

In this work, we have made a simple client-server application on ASP.net. The main functionality of our application is authorization. Our task is to store the user's password in such a way that attackers cannot get the password itself. To protect the user's password, we will store it in the database as a hash. It would be possible to encrypt passwords with a sha-2 or sha-1 hash function, but this is not the most secure option. It is better to use a special function for hashing passwords - argon2(or bcrypt), on top of the hash using sha-3. This method will be protected.

In order for the user's password to be more secure initially, even before hashing, we must apply a set of restrictions on entering the password. The user must come up with a password, which will take a long time to break. The main limitation should be the establishment of a minimum password length, so that the passwords are not too short.
We can allow user to use any symbols, but not using the login the same as password, because it would not be secure.

Hashing is a one-way function (i.e., it is impossible to "decrypt" a hash and obtain the original plaintext value). Hashing is appropriate for password validation. Even if an attacker obtains the hashed password, they cannot enter it into an application's password field and log in as the victim.

By default asp.net uses PBKDF2 for pasword hashing
In order to replace the standard hash function with argon2, we modified the standard functionality of the asp no web application and added passnvod

<img src="lab4/img/img1.png" alt="drawing" width="300"/>

![alt text](lab4/img/img3.png "Title")

Result: 

![alt text](lab4/img/img4.png "Title")

Decrypted passwords:
<img src="lab4/img/img5.png" alt="drawing" width="600"/>

# lab 7 report

## Sensetive data storage
OWASP community advice is to minimize the Storage of Sensitive InformationÂ¶
The best way to protect sensitive information is to not store it in the first place. Although this applies to all kinds of information, it is most often applicable to credit card details, as they are highly desirable for attackers, and PCI DSS has such stringent requirements for how they must be stored. Wherever possible, the storage of sensitive information should be avoided.

For symmetric encryption AES with a key that's at least 128 bits (ideally 256 bits) and a secure mode should be used as the preferred algorithm.
AES - Advanced Encryption Standard

Keys should be randomly generated using a cryptographically secure function, such as those discussed in the Secure Random Number Generation section. Keys should not be based on common words or phrases, or on "random" characters generated by mashing the keyboard.
